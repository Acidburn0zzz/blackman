#!/bin/bash
################################################################################
#                ____                     _ __                                 #
#     ___  __ __/ / /__ ___ ______ ______(_) /___ __                           #
#    / _ \/ // / / (_-</ -_) __/ // / __/ / __/ // /                           #
#   /_//_/\_,_/_/_/___/\__/\__/\_,_/_/ /_/\__/\_, /                            #
#                                            /___/ team                        #
#                                                                              #
# blackman - Emerge for Blackarch                                              #
#                                                                              #
# FILE                                                                         #
# blackman.sh                                                                  #
#                                                                              #
# DATE                                                                         #
# 2013-12-20                                                                   #
#                                                                              #
# DESCRIPTION                                                                  #
# Download and compile packages as Emerge does                                 #
#                                                                              #
# AUTHOR                                                                       #
# nrz@nullsecurity.net                                                         #
# noptrix@nullsecurity.net                                                     #
#                                                                              #
################################################################################


# blackman version
VERSION="blackman v0.2"

# url blackarch repository
REMOTE_REPO="https://github.com/BlackArch/blackarch.git"

# copy of the blackarch repository
LOCAL_REPO="${HOME}/.blackarch"

# meta directory for metadata files
META="${LOCAL_REPO}/meta"

# world file to follow pkg installed
WORLD="${LOCAL_REPO}/meta/world"

# groups file
GROUPS_FILE="${LOCAL_REPO}/docs/misc/groups.lst"

# blackarch packages location
REPO_PKGS="${LOCAL_REPO}/packages"

# error log
ERROR_LOG="${LOCAL_REPO}/meta/errors"

# temporal directory for install packages
TMP_DIR_INSTALL="/tmp"

# true / false
FALSE="0"
TRUE="1"

# return codes
SUCCESS="1337"
FAILURE="31337"

# verbose mode - default: quiet
VERBOSE="/dev/null"

# colors
WHITE="$(tput bold ; tput setaf 7)"
GREEN="$(tput setaf 2)"
RED="$(tput bold; tput setaf 1)"
YELLOW="$(tput bold ; tput setaf 3)"
NC="$(tput sgr0)" # No Color


wprintf() {
    fmt=${1}
    shift
    printf "%s${fmt}%s\n" "${WHITE}" "$@" "${NC}"

    return "${SUCCESS}"
}

# print warning
warn()
{
    fmt=${1}
    shift
    printf "%s[!] WARNING: ${fmt}%s\n" "${RED}" "${@}" "${NC}"

    return "${SUCCESS}"
}

# print error and exit
err()
{
    fmt=${1}
    shift
    printf "[-] ERROR: ${fmt}\n" "${@}" >> "${ERROR_LOG}"
    printf "%s[-] ERROR: ${fmt}%s\n" "${RED}" "${@}" "${NC}"

    return "${SUCCESS}"
}

# print error and exit
cri()
{
    fmt=${1}
    shift
    printf "[-] CRITICAL: ${fmt}%s\n" "${@}" >> "${ERROR_LOG}"
    printf "%s[-] CRITICAL: ${fmt}%s\n" "${RED}" "${@}" "${NC}"
    
    exit "${FAILURE}"
}


# usage and help
usage()
{
    printf "%s" "${WHITE}"
    
    cat <<EOF
Usage: ${0##*/} [options] | <misc>

OPTIONS:

    PACKAGES:
    -s <pkg>: search package
    -i <pkg>: download and compile package
    -g <group>: install all packages inside a blackarch group
    -a: install all packages from all groups

    REPOSITORY:
    -l: list blackarch groups
    -u: update system [not implemented yet - v0.3]
    -d: update blackarch repository

EOF
    
    printf "%s" "${NC}"
    
    return "${SUCCESS}"
}


# leet banner, very important
banner()
{
    printf "%s--==[ blackman by nullsecurity.net ]==--%s\n" "${YELLOW}" "${NC}"

    return "${SUCCESS}"
}


# check argument count
check_argc()
{
    return "${SUCCESS}"
}


# check if required arguments were selected
check_args()
{
    return "${SUCCESS}"
}

check_env()
{
    if [ -f /var/lib/pacman/db.lck ]; then
        cri "Pacman locked - rm /var/lib/pacman/db.lck"
    fi

    command -v strip >/dev/null 2>&1 ||
        err "Blackman needs binutils to work" ||
        pacman -S binutils

    command -v make >/dev/null 2>&1 ||
        err "Blackman needs base-dev to work" ||
        pacman -S base-devel

    return "${SUCCESS}"
}

# check if its first time for blackman and set everything up
check_init()
{
    printf "%s" "${WHITE}"
    # check blackarch repository
    if ! [ -d "${LOCAL_REPO}" ]; then  
        printf "[+] First Blackman Init - Setting up... \n"
        cd "${HOME}"
        git clone "${REMOTE_REPO}" "${LOCAL_REPO}"
    fi
    
    if ! [ -d "${META}" ]; then
        mkdir -p "${META}"
        printf "[+] Creating meta directory...\n"
    fi
    printf "%s" "${NC}"

    return "${SUCCESS}"
}


search()
{
    pkg=${1}
    
    find "${REPO_PKGS}/" -name "*${pkg}*" -type d | while read -r; do
        wprintf "[+] %s" "${REPLY##*/}"
    done

    return "${SUCCESS}"
}
      
install_pkg()
{
    pkg=${1}
    pacman_extra=${2-""}
    #pwd_current=$(pwd)

    if [ -d "${REPO_PKGS}/${pkg}" ]; then	
	cp -R "${REPO_PKGS}/${pkg}" "${TMP_DIR_INSTALL}"
	cd "${TMP_DIR_INSTALL}/${pkg}"

        if [[ ${UID} -ne 0 ]]; then
            makepkg -sf --noconfirm
        else
            makepkg -sf --asroot --noconfirm
        fi

        [ "${?}" != "0" ] && cri "Something wrong with makepkg: %s" "${pkg}"
        sudo pacman -U *.xz ${pacman_extra}
        
        # cleaning up
	    #cd "${pwd_current}"
	    rm -rf "${TMP_DIR_INSTALL}/${pkg}"
	
        ! grep -q "${pkg}" "${WORLD}" && printf "%s\n" "${pkg}" >> "${WORLD}"
    else
        cri "Package not found in repository: %s" "${pkg}"
    fi

    return "${SUCCESS}"
}

install_group()
{
    # TODO: get count of packages - ask if install all
    group=$1

    wprintf "[+] Installing %s group" "${group}"

    if grep -q "^$group$" "${GROUPS_FILE}"; then
        grep -lr "$group" "${REPO_PKGS}" | while read -r; do
            # TODO: nicer?
            rm_file=$(printf "%s" "${REPLY}"|sed 's/\/PKGBUILD//')
            wprintf "[+] Installing %s package" "${rm_file##*/}"
            install_pkg "${rm_file##*/}" "--noconfirm --needed"
        done
    else
        cri "Group %s does not exist" "${group}"
    fi

    return "${SUCCESS}"
}

install_all()
{
    install_group "blackarch"

    return "${SUCCESS}"
}

list_groups()
{
    while read -r; do
        wprintf "[+] %s" "${REPLY}"
    done < "${GROUPS_FILE}"

    return "${SUCCESS}"
}

update_system()
{
    #check date 
    return "${SUCCESS}"
}

update_repo()
{
    printf "%s" "${WHITE}"
    
    cd "${LOCAL_REPO}"
    git pull
    
    printf "%s" "${NC}"

    return "${SUCCESS}"
}

# parse command line options
get_opts()
{
    while getopts s:i:g:auldvVH flags
    do
        case ${flags} in
            s)
                opt_mode="search"
                opt_arg=${OPTARG}
                ;;
            i)
                opt_mode="install_pkg"
                opt_arg=${OPTARG}
                ;;
            g)
                opt_mode="install_group"
                opt_arg=${OPTARG}
                ;;
            a)
                opt_mode="install_all"
                ;;
            l)
                opt_mode="list_groups"
                ;;
            u)
                opt_mode="update_system"
                opt_arg=${OPTARG}
                ;;
            d)
                opt_mode="update_repo"
                ;;
            v)
                VERBOSE="/dev/stdout"
                ;;
            V)
                printf "%s\n" "${VERSION}"
                exit "${SUCCESS}"
                ;;
            H)
                usage
                ;;
            *)
                err "WTF?! mount /dev/brain"
                ;;
        esac
    done

    return "${SUCCESS}"
}


# controller and program flow
main()
{
    banner
    check_argc ${*}
    get_opts ${*}
    check_args ${*}
    check_env
    check_init 

    case "${opt_mode}" in
        "search")
            search "${opt_arg}"
            ;;
        "install_pkg")
            install_pkg "${opt_arg}"
            ;;
        "install_group")
            install_group "${opt_arg}"
            ;;
        "install_all")
            install_all
            ;;
        "update_repo")
            update_repo
            ;;
        "list_groups")
            list_groups
            ;;
        *)
            usage
            ;;
    esac
    return "${SUCCESS}"
}


# program start
main ${*}

# EOF
